const EventManager = require('../../src/EventManager');
const EventStorage = require('../../src/EventStorage');

// Mock EventStorage
jest.mock('../../src/EventStorage');

// Use Jest fake timers for timer control
jest.useFakeTimers();

describe('EventManager', () => {
    let eventManager;
    let mockBot;
    let mockGuild;
    let mockChannel;
    let mockRole;
    let mockEventStorage;

    beforeEach(() => {
        // Reset all mocks
        jest.clearAllMocks();
        jest.clearAllTimers();

        // Create mock EventStorage instance
        mockEventStorage = {
            createEvent: jest.fn(),
            getUpcomingEvents: jest.fn(),
            updateReminderStatus: jest.fn(),
            getEventsByRegion: jest.fn(),
            getUpcomingEventsByRegion: jest.fn(),
            getUpcomingEventsByLocation: jest.fn(),
            deleteEvent: jest.fn()
        };

        // Mock EventStorage constructor
        EventStorage.mockImplementation(() => mockEventStorage);

        // Mock bot and Discord objects
        mockRole = {
            id: 'role123',
            name: 'London'
        };

        mockLocationRole = {
            id: 'role124',
            name: 'Central London'
        };

        mockChannel = {
            id: 'channel123',
            name: 'regional-london',
            type: 0,
            send: jest.fn().mockResolvedValue({ id: 'msg123' })
        };

        const rolesMap = new Map([['role123', mockRole], ['role124', mockLocationRole]]);
        rolesMap.find = function(predicate) {
            for (const role of this.values()) {
                if (predicate(role)) return role;
            }
            return undefined;
        };

        const channelsMap = new Map([['channel123', mockChannel]]);
        channelsMap.find = function(predicate) {
            for (const channel of this.values()) {
                if (predicate(channel)) return channel;
            }
            return undefined;
        };

        mockGuild = {
            id: 'guild123',
            roles: {
                cache: rolesMap
            },
            channels: {
                cache: channelsMap
            }
        };

        mockBot = {
            client: {
                guilds: {
                    cache: new Map([
                        ['guild123', mockGuild]
                    ])
                }
            },
            getGuildId: jest.fn().mockReturnValue('guild123'),
            getEventsTable: jest.fn().mockReturnValue('events-table'),
            getConfig: jest.fn().mockReturnValue({}),
            getReminderIntervals: jest.fn().mockReturnValue({
                weekReminder: 7 * 24 * 60 * 60 * 1000, // 7 days in ms
                dayReminder: 24 * 60 * 60 * 1000 // 24 hours in ms
            })
        };

        // Create EventManager instance
        eventManager = new EventManager(mockBot);
    });

    afterEach(() => {
        // Clear all timers after each test
        jest.clearAllTimers();
        
        // Clean up EventManager timers if instance exists
        if (eventManager && typeof eventManager.cleanup === 'function') {
            eventManager.cleanup();
        }
    });

    afterAll(() => {
        // Restore real timers
        jest.useRealTimers();
    });

    describe('constructor', () => {
        test('should initialize with bot and storage', () => {
            expect(EventStorage).toHaveBeenCalledWith('events-table');
            expect(eventManager.bot).toBe(mockBot);
            expect(eventManager.storage).toBe(mockEventStorage);
        });

        test('should start dynamic reminder system when not in Jest', () => {
            // Temporarily remove JEST_WORKER_ID to allow reminder system to start
            const originalJestWorkerId = process.env.JEST_WORKER_ID;
            delete process.env.JEST_WORKER_ID;

            const consoleSpy = jest.spyOn(console, 'log').mockImplementation();
            const setTimeoutSpy = jest.spyOn(global, 'setTimeout');
            
            // Create new EventManager without JEST_WORKER_ID
            const newEventManager = new EventManager(mockBot);

            try {
                expect(setTimeoutSpy).toHaveBeenCalledWith(
                    expect.any(Function),
                    10000 // 10 seconds startup delay
                );
                expect(consoleSpy).toHaveBeenCalledWith('Starting dynamic reminder system...');
            } finally {
                // Always restore JEST_WORKER_ID
                if (originalJestWorkerId) {
                    process.env.JEST_WORKER_ID = originalJestWorkerId;
                }
                if (newEventManager && typeof newEventManager.cleanup === 'function') {
                    newEventManager.cleanup();
                }
                setTimeoutSpy.mockRestore();
                consoleSpy.mockRestore();
            }
        });
    });

    describe('createEvent', () => {
        const futureDate = new Date(Date.now() + 24 * 60 * 60 * 1000); // Tomorrow
        const validEventData = {
            name: 'Community Meeting',
            region: 'London',
            location: 'Central London',
            eventDate: futureDate.toISOString().substring(0, 16).replace('T', ' '),
            description: 'Test meeting'
        };

        const createdBy = { id: 'user123', tag: 'TestUser#1234' };

        test('should create event successfully', async () => {
            // Mock successful validation and storage
            mockEventStorage.createEvent.mockResolvedValue({
                ...validEventData,
                event_id: 'event123',
                created_by: 'user123'
            });

            // Spy on sendEventNotification to debug
            const sendNotificationSpy = jest.spyOn(eventManager, 'sendEventNotification')
                .mockResolvedValue();

            const result = await eventManager.createEvent('guild123', validEventData, createdBy);

            expect(mockEventStorage.createEvent).toHaveBeenCalledWith('guild123', {
                ...validEventData,
                eventDate: expect.any(String), // Now converted to ISO string
                createdBy: 'user123'
            });
            expect(sendNotificationSpy).toHaveBeenCalled();
            expect(result.event_id).toBe('event123');
        });

        test('should reject invalid event data', async () => {
            const invalidEventData = {
                name: '',
                region: 'London',
                eventDate: '2024-12-25 18:00'
            };

            await expect(eventManager.createEvent('guild123', invalidEventData, createdBy))
                .rejects.toThrow('Event name is required');
        });

        test('should reject missing region', async () => {
            const invalidEventData = {
                name: 'Test Event',
                eventDate: '2024-12-25 18:00'
            };

            await expect(eventManager.createEvent('guild123', invalidEventData, createdBy))
                .rejects.toThrow('Region is required');
        });

        test('should reject past dates', async () => {
            const invalidEventData = {
                name: 'Test Event',
                region: 'London',
                eventDate: '2020-01-01 12:00'
            };

            await expect(eventManager.createEvent('guild123', invalidEventData, createdBy))
                .rejects.toThrow('Event date must be in the future');
        });

        test('should reject invalid date format', async () => {
            const invalidEventData = {
                name: 'Test Event',
                region: 'London',
                eventDate: 'invalid-date'
            };

            await expect(eventManager.createEvent('guild123', invalidEventData, createdBy))
                .rejects.toThrow('Invalid date format');
        });

        test('should reject non-existent region role', async () => {
            const futureDate = new Date(Date.now() + 24 * 60 * 60 * 1000);
            const invalidEventData = {
                name: 'Test Event',
                region: 'NonExistentRegion',
                eventDate: futureDate.toISOString().substring(0, 16).replace('T', ' ')
            };

            await expect(eventManager.createEvent('guild123', invalidEventData, createdBy))
                .rejects.toThrow('Region role "NonExistentRegion" not found');
        });

        test('should handle guild not found', async () => {
            mockBot.client.guilds.cache.clear();

            await expect(eventManager.createEvent('guild123', validEventData, createdBy))
                .rejects.toThrow('Guild not found');
        });
    });

    describe('validateEventData', () => {
        test('should validate correct event data', () => {
            const futureDate = new Date(Date.now() + 24 * 60 * 60 * 1000);
            const validData = {
                name: 'Test Event',
                region: 'London',
                eventDate: futureDate.toISOString().substring(0, 16).replace('T', ' ')
            };

            const result = eventManager.validateEventData(validData);
            expect(result.valid).toBe(true);
        });

        test('should reject empty name', () => {
            const invalidData = {
                name: '',
                region: 'London',
                eventDate: '2024-12-25 18:00'
            };

            const result = eventManager.validateEventData(invalidData);
            expect(result.valid).toBe(false);
            expect(result.error).toBe('Event name is required');
        });

        test('should reject missing region', () => {
            const invalidData = {
                name: 'Test Event',
                eventDate: '2024-12-25 18:00'
            };

            const result = eventManager.validateEventData(invalidData);
            expect(result.valid).toBe(false);
            expect(result.error).toBe('Region is required');
        });

        test('should reject missing date', () => {
            const invalidData = {
                name: 'Test Event',
                region: 'London'
            };

            const result = eventManager.validateEventData(invalidData);
            expect(result.valid).toBe(false);
            expect(result.error).toBe('Event date is required');
        });
    });

    describe('findRoleByName', () => {
        test('should find role by exact name', () => {
            const result = eventManager.findRoleByName(mockGuild, 'London');
            expect(result).toBe(mockRole);
        });

        test('should find role by case insensitive name', () => {
            const result = eventManager.findRoleByName(mockGuild, 'london');
            expect(result).toBe(mockRole);
        });

        test('should return undefined for non-existent role', () => {
            const result = eventManager.findRoleByName(mockGuild, 'NonExistent');
            expect(result).toBeUndefined();
        });
    });

    describe('scheduleNextReminder', () => {
        test('should schedule next reminder when events exist', async () => {
            const upcomingEvents = [
                {
                    guild_id: 'guild123',
                    event_id: 'event1',
                    name: 'Test Event',
                    region: 'London',
                    event_date: new Date(Date.now() + 6 * 24 * 60 * 60 * 1000).toISOString(),
                    created_at: new Date().toISOString(),
                    reminder_status: 'pending'
                }
            ];

            mockEventStorage.getUpcomingEvents.mockResolvedValue(upcomingEvents);
            const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

            await eventManager.scheduleNextReminder();

            expect(mockEventStorage.getUpcomingEvents).toHaveBeenCalledWith('guild123');
            expect(consoleSpy).toHaveBeenCalledWith(
                expect.stringContaining('Next reminder scheduled')
            );
            
            consoleSpy.mockRestore();
        });

        test('should handle no upcoming events', async () => {
            mockEventStorage.getUpcomingEvents.mockResolvedValue([]);
            const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

            await eventManager.scheduleNextReminder();

            expect(consoleSpy).toHaveBeenCalledWith('🔔 No upcoming events - scheduling check in 1 hour');
            consoleSpy.mockRestore();
        });

        test('should handle errors gracefully', async () => {
            mockEventStorage.getUpcomingEvents.mockRejectedValue(new Error('Database error'));
            const consoleSpy = jest.spyOn(console, 'error').mockImplementation();

            await eventManager.scheduleNextReminder();

            expect(consoleSpy).toHaveBeenCalledWith('Error scheduling next reminder:', expect.any(Error));
            consoleSpy.mockRestore();
        });
    });

    describe('processEventReminder', () => {
        test('should send 7-day reminder', async () => {
            const event = {
                guild_id: 'guild123',
                event_id: 'event1',
                name: 'Test Event',
                region: 'London',
                event_date: new Date(Date.now() + 6 * 24 * 60 * 60 * 1000).toISOString(),
                reminder_status: 'pending'
            };

            const sendEventReminderSpy = jest.spyOn(eventManager, 'sendEventReminder')
                .mockResolvedValue();

            await eventManager.processEventReminder(event);

            expect(sendEventReminderSpy).toHaveBeenCalledWith(event, 'first', 7 * 24 * 60 * 60 * 1000, false);
            expect(mockEventStorage.updateReminderStatus).toHaveBeenCalledWith(
                'guild123', 'event1', 'week_sent'
            );
        });

        test('should send 24-hour reminder', async () => {
            const event = {
                guild_id: 'guild123',
                event_id: 'event1',
                name: 'Test Event',
                region: 'London',
                event_date: new Date(Date.now() + 12 * 60 * 60 * 1000).toISOString(),
                reminder_status: 'week_sent'
            };

            const sendEventReminderSpy = jest.spyOn(eventManager, 'sendEventReminder')
                .mockResolvedValue();

            await eventManager.processEventReminder(event);

            expect(sendEventReminderSpy).toHaveBeenCalledWith(event, 'second', 24 * 60 * 60 * 1000, false);
            expect(mockEventStorage.updateReminderStatus).toHaveBeenCalledWith(
                'guild123', 'event1', 'day_sent'
            );
        });

        test('should not send reminder if not time yet', async () => {
            const event = {
                guild_id: 'guild123',
                event_id: 'event1',
                name: 'Test Event',
                region: 'London',
                event_date: new Date(Date.now() + 10 * 24 * 60 * 60 * 1000).toISOString(),
                reminder_status: 'pending'
            };

            const sendEventReminderSpy = jest.spyOn(eventManager, 'sendEventReminder')
                .mockResolvedValue();

            await eventManager.processEventReminder(event);

            expect(sendEventReminderSpy).not.toHaveBeenCalled();
            expect(mockEventStorage.updateReminderStatus).not.toHaveBeenCalled();
        });
    });

    describe('sendEventReminder', () => {
        const event = {
            guild_id: 'guild123',
            event_id: 'event1',
            name: 'Test Event',
            region: 'London',
            event_date: new Date('2024-12-25T18:00:00Z').toISOString(),
            created_by: 'user123'
        };

        test('should send reminder to regional channel', async () => {
            await eventManager.sendEventReminder(event, '7-day');

            expect(mockChannel.send).toHaveBeenCalledWith(
                expect.objectContaining({
                    content: expect.stringContaining('Event reminder!'),
                    embeds: expect.arrayContaining([
                        expect.objectContaining({
                            title: expect.stringContaining('Event Reminder'),
                            description: expect.stringContaining('Test Event'),
                            color: 0xffd700
                        })
                    ])
                })
            );
        });

        test('should use different color for 24-hour reminder', async () => {
            await eventManager.sendEventReminder(event, '24-hour');

            expect(mockChannel.send).toHaveBeenCalledWith(
                expect.objectContaining({
                    embeds: expect.arrayContaining([
                        expect.objectContaining({
                            color: 0xff4500
                        })
                    ])
                })
            );
        });

        test('should handle guild not found', async () => {
            mockBot.client.guilds.cache.clear();

            await eventManager.sendEventReminder(event, '7-day');

            expect(mockChannel.send).not.toHaveBeenCalled();
        });
    });

    describe('getEventsByRegion', () => {
        test('should delegate to storage', async () => {
            const expectedEvents = [{ id: 'event1' }];
            mockEventStorage.getEventsByRegion.mockResolvedValue(expectedEvents);

            const result = await eventManager.getEventsByRegion('guild123', 'London');

            expect(mockEventStorage.getEventsByRegion).toHaveBeenCalledWith('guild123', 'London');
            expect(result).toBe(expectedEvents);
        });
    });

    describe('deleteEvent', () => {
        test('should delegate to storage', async () => {
            mockEventStorage.deleteEvent.mockResolvedValue();

            await eventManager.deleteEvent('guild123', 'event123');

            expect(mockEventStorage.deleteEvent).toHaveBeenCalledWith('guild123', 'event123');
        });
    });

    describe('getUpcomingEventsByRegion', () => {
        test('should delegate to storage with limit', async () => {
            const expectedEvents = [{ id: 'event1' }, { id: 'event2' }];
            mockEventStorage.getUpcomingEventsByRegion.mockResolvedValue(expectedEvents);

            const result = await eventManager.getUpcomingEventsByRegion('guild123', 'London');

            expect(mockEventStorage.getUpcomingEventsByRegion).toHaveBeenCalledWith('guild123', 'London', 3);
            expect(result).toBe(expectedEvents);
        });
    });

    describe('getUpcomingEventsByLocation', () => {
        test('should delegate to storage with limit', async () => {
            const expectedEvents = [{ id: 'event1' }];
            mockEventStorage.getUpcomingEventsByLocation.mockResolvedValue(expectedEvents);

            const result = await eventManager.getUpcomingEventsByLocation('guild123', 'Manchester');

            expect(mockEventStorage.getUpcomingEventsByLocation).toHaveBeenCalledWith('guild123', 'Manchester', 3);
            expect(result).toBe(expectedEvents);
        });
    });

    describe('formatIntervalTime', () => {
        test('should format days correctly', () => {
            const threeDays = 3 * 24 * 60 * 60 * 1000;
            expect(eventManager.formatIntervalTime(threeDays)).toBe('3 days before event');
            expect(eventManager.formatIntervalTime(threeDays, true)).toBe('3 days after creation');
        });

        test('should format single day correctly', () => {
            const oneDay = 24 * 60 * 60 * 1000;
            expect(eventManager.formatIntervalTime(oneDay)).toBe('1 day before event');
        });

        test('should format hours correctly', () => {
            const twoHours = 2 * 60 * 60 * 1000;
            expect(eventManager.formatIntervalTime(twoHours)).toBe('2 hours before event');
            expect(eventManager.formatIntervalTime(twoHours, true)).toBe('2 hours after creation');
        });

        test('should format single hour correctly', () => {
            const oneHour = 60 * 60 * 1000;
            expect(eventManager.formatIntervalTime(oneHour)).toBe('1 hour before event');
        });

        test('should format minutes correctly', () => {
            const thirtyMinutes = 30 * 60 * 1000;
            expect(eventManager.formatIntervalTime(thirtyMinutes)).toBe('30 mins before event');
        });

        test('should format single minute correctly', () => {
            const oneMinute = 60 * 1000;
            expect(eventManager.formatIntervalTime(oneMinute)).toBe('1 min before event');
        });

        test('should format seconds correctly', () => {
            const thirtySeconds = 30 * 1000;
            expect(eventManager.formatIntervalTime(thirtySeconds)).toBe('30 secs before event');
        });

        test('should format single second correctly', () => {
            const oneSecond = 1000;
            expect(eventManager.formatIntervalTime(oneSecond)).toBe('1 sec before event');
        });
    });

    describe('sendEventNotification', () => {
        const event = {
            guild_id: 'guild123',
            event_id: 'event1',
            name: 'Test Community Event',
            region: 'London',
            location: 'Central London',
            description: 'A test event description',
            link: 'https://example.com/event',
            event_date: new Date('2024-12-25T18:00:00Z').toISOString(),
            created_by: 'user123'
        };

        test('should send notification to regional channel', async () => {
            // Debug the search logic
            console.log('Event region:', event.region);
            console.log('Expected channel name:', `regional-${event.region.toLowerCase().replace(/\s+/g, '-')}`);
            console.log('Available channels:', Array.from(mockGuild.channels.cache.values()).map(c => c.name));
            
            await eventManager.sendEventNotification(mockGuild, event, mockRole, mockLocationRole);

            expect(mockChannel.send).toHaveBeenCalledWith(
                expect.objectContaining({
                    content: expect.stringContaining('New event in your region!'),
                    embeds: expect.arrayContaining([
                        expect.objectContaining({
                            title: '🎉 New Regional Event',
                            description: expect.stringContaining('Test Community Event'),
                            color: 0x00ff00
                        })
                    ])
                })
            );
        });

        test('should send notification to location channel when available', async () => {
            // Add local channel to mock guild
            const localChannel = {
                id: 'localchannel123',
                name: 'local-central-london',
                type: 0,
                send: jest.fn().mockResolvedValue({ id: 'msg456' })
            };
            
            const channelsMapWithLocal = new Map([
                ['channel123', mockChannel], 
                ['localchannel123', localChannel]
            ]);
            channelsMapWithLocal.find = function(predicate) {
                for (const channel of this.values()) {
                    if (predicate(channel)) return channel;
                }
                return undefined;
            };
            
            mockGuild.channels.cache = channelsMapWithLocal;

            await eventManager.sendEventNotification(mockGuild, event, mockRole, mockLocationRole);

            // Should send to both regional and local channels
            expect(mockChannel.send).toHaveBeenCalled(); // regional
            expect(localChannel.send).toHaveBeenCalledWith(
                expect.objectContaining({
                    content: expect.stringContaining('New event in your area!'),
                    embeds: expect.arrayContaining([
                        expect.objectContaining({
                            title: '🎉 New Local Event'
                        })
                    ])
                })
            );
        });

        test('should handle event without location', async () => {
            const eventWithoutLocation = { ...event, location: null };

            await eventManager.sendEventNotification(mockGuild, eventWithoutLocation, mockRole, null);

            expect(mockChannel.send).toHaveBeenCalledWith(
                expect.objectContaining({
                    embeds: expect.arrayContaining([
                        expect.objectContaining({
                            description: expect.not.stringContaining('🏘️ **Location:**')
                        })
                    ])
                })
            );
        });

        test('should handle event without description', async () => {
            const eventWithoutDesc = { ...event };
            delete eventWithoutDesc.description;
            
            const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

            await eventManager.sendEventNotification(mockGuild, eventWithoutDesc, mockRole, mockLocationRole);

            expect(mockChannel.send).toHaveBeenCalledWith(
                expect.objectContaining({
                    embeds: expect.arrayContaining([
                        expect.objectContaining({
                            description: expect.not.stringContaining('📝 **Description:**')
                        })
                    ])
                })
            );
            consoleSpy.mockRestore();
        });

        test('should handle event without link', async () => {
            const eventWithoutLink = { ...event };
            delete eventWithoutLink.link;
            
            const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

            await eventManager.sendEventNotification(mockGuild, eventWithoutLink, mockRole, mockLocationRole);

            expect(mockChannel.send).toHaveBeenCalledWith(
                expect.objectContaining({
                    embeds: expect.arrayContaining([
                        expect.objectContaining({
                            description: expect.not.stringContaining('🔗 **Link:**')
                        })
                    ])
                })
            );
            consoleSpy.mockRestore();
        });

        test('should handle errors in notification sending', async () => {
            mockChannel.send.mockRejectedValue(new Error('Channel send failed'));
            const consoleSpy = jest.spyOn(console, 'error').mockImplementation();

            // Should not throw, should handle error gracefully
            await eventManager.sendEventNotification(mockGuild, event, mockRole, mockLocationRole);

            expect(consoleSpy).toHaveBeenCalledWith('Error sending event notification:', expect.any(Error));
            consoleSpy.mockRestore();
        });
    });

    describe('processEventReminder - development mode', () => {
        beforeEach(() => {
            // Mock bot with negative intervals (dev mode)
            mockBot.getReminderIntervals.mockReturnValue({
                weekReminder: -2 * 60 * 1000, // -2 minutes (after creation)
                dayReminder: -1 * 60 * 1000   // -1 minute (after creation)
            });
            
            // Recreate EventManager with dev mode intervals
            eventManager = new EventManager(mockBot);
        });

        test('should send first reminder after creation time in dev mode', async () => {
            const event = {
                guild_id: 'guild123',
                event_id: 'event1',
                name: 'Test Event',
                region: 'London',
                event_date: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
                created_at: new Date(Date.now() - 3 * 60 * 1000).toISOString(), // 3 minutes ago
                reminder_status: 'pending'
            };

            const sendEventReminderSpy = jest.spyOn(eventManager, 'sendEventReminder')
                .mockResolvedValue();

            await eventManager.processEventReminder(event);

            expect(sendEventReminderSpy).toHaveBeenCalledWith(event, 'first', -2 * 60 * 1000, true);
            expect(mockEventStorage.updateReminderStatus).toHaveBeenCalledWith(
                'guild123', 'event1', 'week_sent'
            );
        });

        test('should send second reminder in dev mode', async () => {
            const event = {
                guild_id: 'guild123',
                event_id: 'event1',
                name: 'Test Event',
                region: 'London',
                event_date: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
                created_at: new Date(Date.now() - 4 * 60 * 1000).toISOString(), // 4 minutes ago (past both thresholds)
                reminder_status: 'week_sent'
            };

            const sendEventReminderSpy = jest.spyOn(eventManager, 'sendEventReminder')
                .mockResolvedValue();

            await eventManager.processEventReminder(event);

            expect(sendEventReminderSpy).toHaveBeenCalledWith(event, 'second', -1 * 60 * 1000, true);
            expect(mockEventStorage.updateReminderStatus).toHaveBeenCalledWith(
                'guild123', 'event1', 'day_sent'
            );
        });
    });

    describe('processEventReminder error handling', () => {
        test('should handle errors gracefully', async () => {
            const event = {
                guild_id: 'guild123',
                event_id: 'event1',
                name: 'Test Event',
                region: 'London',
                event_date: 'invalid-date', // This will cause an error
                reminder_status: 'pending'
            };

            const consoleSpy = jest.spyOn(console, 'error').mockImplementation();

            await eventManager.processEventReminder(event);

            expect(consoleSpy).toHaveBeenCalledWith(
                expect.stringContaining('Error processing reminder for event event1:'), 
                expect.any(Error)
            );
            consoleSpy.mockRestore();
        });
    });

    describe('sendEventReminder - location channel handling', () => {
        const event = {
            guild_id: 'guild123',
            event_id: 'event1',
            name: 'Test Event',
            region: 'London',
            location: 'Central London',
            event_date: new Date('2024-12-25T18:00:00Z').toISOString(),
            created_by: 'user123'
        };

        test('should send reminder to location channel when available', async () => {
            const localChannel = {
                id: 'localchannel123',
                name: 'local-central-london',
                type: 0,
                send: jest.fn().mockResolvedValue({ id: 'msg456' })
            };
            
            const channelsMapWithLocal = new Map([
                ['channel123', mockChannel], 
                ['localchannel123', localChannel]
            ]);
            channelsMapWithLocal.find = function(predicate) {
                for (const channel of this.values()) {
                    if (predicate(channel)) return channel;
                }
                return undefined;
            };
            
            mockGuild.channels.cache = channelsMapWithLocal;

            await eventManager.sendEventReminder(event, 'first', 7 * 24 * 60 * 60 * 1000, false);

            expect(localChannel.send).toHaveBeenCalledWith(
                expect.objectContaining({
                    content: expect.stringContaining('Event reminder!'),
                    embeds: expect.arrayContaining([
                        expect.objectContaining({
                            title: expect.stringContaining('Event Reminder'),
                            color: 0xffd700
                        })
                    ])
                })
            );
        });

        test('should use correct emoji for after-creation mode', async () => {
            await eventManager.sendEventReminder(event, 'first', -2 * 60 * 1000, true);

            expect(mockChannel.send).toHaveBeenCalledWith(
                expect.objectContaining({
                    embeds: expect.arrayContaining([
                        expect.objectContaining({
                            title: expect.stringContaining('🧪')
                        })
                    ])
                })
            );
        });

        test('should use correct emoji for second reminder in after-creation mode', async () => {
            await eventManager.sendEventReminder(event, 'second', -1 * 60 * 1000, true);

            expect(mockChannel.send).toHaveBeenCalledWith(
                expect.objectContaining({
                    embeds: expect.arrayContaining([
                        expect.objectContaining({
                            title: expect.stringContaining('🔬')
                        })
                    ])
                })
            );
        });

        test('should use hour emoji for short intervals', async () => {
            await eventManager.sendEventReminder(event, 'second', 2 * 60 * 60 * 1000, false);

            expect(mockChannel.send).toHaveBeenCalledWith(
                expect.objectContaining({
                    embeds: expect.arrayContaining([
                        expect.objectContaining({
                            title: expect.stringContaining('⏰')
                        })
                    ])
                })
            );
        });

        test('should use bell emoji for very short intervals', async () => {
            await eventManager.sendEventReminder(event, 'second', 30 * 60 * 1000, false);

            expect(mockChannel.send).toHaveBeenCalledWith(
                expect.objectContaining({
                    embeds: expect.arrayContaining([
                        expect.objectContaining({
                            title: expect.stringContaining('🔔')
                        })
                    ])
                })
            );
        });
    });

    describe('cleanup', () => {
        test('should clean up all timers', () => {
            const consoleSpy = jest.spyOn(console, 'log').mockImplementation();
            
            eventManager.cleanup();

            expect(consoleSpy).toHaveBeenCalledWith('EventManager timers cleaned up');
            consoleSpy.mockRestore();
        });
    });

    describe('constructor error handling', () => {
        test('should throw error when reminder intervals not configured', () => {
            const badMockBot = {
                ...mockBot,
                getReminderIntervals: jest.fn().mockReturnValue(null)
            };

            expect(() => new EventManager(badMockBot))
                .toThrow('Reminder intervals not configured in bot');
        });
    });
});